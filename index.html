<!DOCTYPE html>
<html lang="si">
<head>
  <meta charset="UTF-8" />
  <title>‡∑Å‡∑í‡∑Ç‡∑ä‚Äç‡∂∫ ‡∂±‡∑è‡∂∫‡∂ö ‡∂ö‡∑è‡∂ª‡∑ä‡∂∫ ‡∂∂‡∑ô‡∂Ø‡∑è‡∑Ñ‡∑ê‡∂ª‡∑ì‡∂∏</title>
  <link href="https://fonts.googleapis.com/css2?family=Abhaya+Libre:wght@700&display=swap" rel="stylesheet" />
  <style>
    body {
      font-family: 'Abhaya Libre', serif;
      background-color: #f9f9f9;
      padding: 20px;
    }
    h1 {
      text-align: center;
      font-size: 32px;
      font-weight: 700;
      margin-bottom: 20px;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      background-color: white;
      margin-top: 20px;
      box-shadow: 0 0 10px #ccc;
    }
    th, td {
      border: 1px solid #999;
      padding: 12px;
      font-size: 18px;
      font-weight: 700;
      text-align: left;
    }
    th {
      background-color: #d9d9d9;
    }
    button {
      margin: 15px auto;
      display: block;
      background-color: #007bff;
      color: white;
      font-size: 18px;
      padding: 10px 20px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 700;
    }
    button:hover {
      background-color: #0056b3;
    }
    @media print {
      button {
        display: none;
      }
    }
  </style>
</head>
<body>

  <h1>‡∑Å‡∑í‡∑Ç‡∑ä‚Äç‡∂∫ ‡∂±‡∑è‡∂∫‡∂ö ‡∂±‡∑è‡∂∫‡∑í‡∂ö‡∑è ‡∂ö‡∑è‡∂ª‡∑ä‡∂∫ ‡∂∂‡∑ô‡∂Ø‡∑è‡∑Ñ‡∑ê‡∂ª‡∑ì‡∂∏</h1>

  <button onclick="shuffleAndRender()">Shuffle</button>
  <button onclick="window.print()">üìÑ Generate a PDF File</button>

  <table>
    <thead>
      <tr>
        <th>‡∂Ö‡∂Ç‡∂ö‡∂∫</th>
        <th>‡∂ö‡∑è‡∂ª‡∑ä‡∂∫‡∂∫</th>
        <th>‡∂±‡∂∏</th>
      </tr>
    </thead>
    <tbody id="taskTableBody"></tbody>
  </table>

  <script>
    const sentences = [
      "‡∂¥‡∑ô.‡∑Ä 6.35‡∂ß ‡∂ã‡∂¥‡∂Ø‡∑ö‡∑Å ‡∂ú‡∑ì‡∂≠ ‡∑Å‡∂∂‡∑ä‡∂Ø ‡∑Ä‡∑í‡∂ö‡∑è‡∑Å‡∂± ‡∂∫‡∂±‡∑ä‡∂≠‡∑ä‚Äç‡∂ª‡∂∫ ‡∂∏‡∂ú‡∑í‡∂±‡∑ä ‡∑Ä‡∑í‡∂ö‡∑è‡∑Å‡∂±‡∂∫ ‡∂ö‡∑í‡∂ª‡∑ì‡∂∏.",
      "‡∂¥‡∑ô.‡∑Ä 6.45 ‡∑Ä‡∂± ‡∑Ä‡∑í‡∂ß ‡∂Ø‡∑Ñ‡∂∏‡∑ä ‡∂¥‡∑è‡∑É‡∂Ω‡∂ß ‡∂Ö‡∂±‡∑í‡∑Ä‡∑è‡∂ª‡∑ä‡∂∫‡∂∫‡∑ô‡∂±‡∑ä ‡∂∏ ‡∂¥‡∑ê‡∂∏‡∑í‡∂´ ‡∑É‡∑í‡∂ß‡∑í‡∂∫ ‡∂∫‡∑î‡∂≠‡∑î‡∂∫.",
      "‡∂¥‡∑ô.‡∑Ä 6.45‡∂ß ‡∑É‡∂≠‡∑í‡∂∏‡∂≠‡∑ä ‡∂∂‡∑Ä ‡∑Ä‡∑ê‡∂©‡∑ì‡∂∏ ‡∂≠‡∑î‡∂Ω‡∑í‡∂±‡∑ä ‡∂Ø‡∑Ä‡∑É‡∑ö ‡∂ö‡∂Ω‡∂∫‡∑î‡∂≠‡∑î ‡∂ö‡∑ä‚Äç‡∂ª‡∑í‡∂∫‡∑è‡∂ö‡∑è‡∂ª‡∂ö‡∂∏‡∑ä ‡∂¥‡∑í‡∂Ω‡∑í‡∂∂‡∂Ø ‡∑É‡∑ä‡∂∏‡∂ª‡∂´‡∂∫ ‡∂ö‡∑í‡∂ª‡∑ì‡∂∏.",
      "‡∂ö‡∑è‡∂ª‡∑ä‚Äç‡∂∫‡∑è‡∂Ω‡∂∫ ‡∂∏‡∑ö‡∑É‡∂∫ ‡∂¥‡∑í‡∂Ω‡∑í‡∑Ä‡∑ô‡∂Ω‡∂ö‡∂ß ‡∑É‡∂ö‡∑É‡∑ä ‡∂ö‡∑í‡∂ª‡∑ì‡∂∏,‡∂∏‡∑ö‡∑É ‡∂á‡∂≠‡∑í‡∂ª‡∑í‡∂Ω‡∑í,‡∑É‡∑ì‡∂±‡∑î‡∑Ä ‡∑Ñ‡∑è ‡∑Å‡∑í‡∑Ç‡∑ä‚Äç‡∂∫ ‡∂±‡∑è‡∂∫‡∂ö ,‡∂±‡∑è‡∂∫‡∑í‡∂ö‡∑è ‡∂¥‡∑ê‡∂∏‡∑í‡∂´‡∑ì‡∂∏‡∑ö ‡∂Ω‡∑ö‡∂õ‡∂±‡∂∫ ‡∑É‡∂ö‡∑É‡∑ä ‡∂ö‡∂ª ‡∂ë‡∑Ñ‡∑í ‡∂≠‡∑ê‡∂∂‡∑ì‡∂∏.",
      "‡∑Å‡∑í‡∑Ç‡∑ä‚Äç‡∂∫‡∂∫‡∂±‡∑ä‡∂ú‡∑ö ‡∂∂‡∑ë‡∂ú‡∑ä ‡∂¥‡∂ª‡∑ì‡∂ö‡∑ä‡∑Ç‡∑è‡∑Ä.",
      "‡∂∞‡∂ª‡∑ä‡∂∏ ‡∑Å‡∑è‡∂Ω‡∑è‡∑Ä ‡∂¥‡∑í‡∂ª‡∑í‡∑É‡∑í‡∂Ø‡∑î ‡∂ö‡∑í‡∂ª‡∑ì‡∂∏.",
      "‡∂¥‡∑ñ‡∂ª‡∑ä‡∑Ä ‡∂¥‡∑ä‚Äç‡∂ª‡∑è‡∂≠‡∂∏‡∑í‡∂ö ‡∑Å‡∑ä‚Äç‡∂ª‡∑ö‡∂´‡∑í ‡∑Ä‡∂Ω ‡∂¥‡∂±‡∑ä‡∂≠‡∑í ‡∂ö‡∑è‡∂∏‡∂ª ‡∂¥‡∑í‡∂ª‡∑í‡∑É‡∑í‡∂Ø‡∑î ‡∂ö‡∂ª ‡∑É‡∂ö‡∑É‡∑ä ‡∂ö‡∑í‡∂ª‡∑ì‡∂∏.",
      "‡∂∂‡∑î‡∂Ø‡∑ä‡∂Ø ‡∑Ä‡∂±‡∑ä‡∂Ø‡∂±‡∑è ‡∑Ä‡∑ê‡∂©‡∑É‡∂ß‡∑Ñ‡∂± ‡∂¥‡∑ê‡∑Ä‡∑ê‡∂≠‡∑ä‡∑Ä‡∑ô‡∂± ‡∑É‡∑ä‡∂Æ‡∑è‡∂±‡∂∫ ‡∑Ñ‡∑è ‡∂∂‡∑ù‡∂Ø‡∑í ‡∂∏‡∂Ω‡∑î‡∑Ä ‡∂á‡∂∏‡∂Ø‡∑ì‡∂∏.",
      "‡∂∏‡∂Ω‡∑ä ‡∂Ü‡∑É‡∂± ‡∑Ñ‡∑è ‡∑É‡∑ë ‡∂ª‡∂Ø‡∑î‡∂±‡∑ä ‡∂Ö‡∂∂‡∑í‡∂∫‡∑É ‡∂¥‡∑í‡∂ª‡∑í‡∑É‡∑í‡∂Ø‡∑î ‡∂ö‡∑ú‡∂ß ‡∂¥‡∑í‡∂Ω‡∑í‡∂∫‡∑ô‡∂Ω ‡∂ö‡∑í‡∂ª‡∑ì‡∂∏.",
      "‡∑É‡∂∏‡∑ä‡∂∂‡∑î‡∂Ø‡∑ä‡∂∞ ‡∂¥‡∑ñ‡∂¢‡∑è‡∑Ä‡∂ß ‡∂Ö‡∑Ä‡∑Å‡∂∫ ‡∂¥‡∑ñ‡∂¢‡∑è ‡∑Ñ‡∑ú‡∂Ø‡∑í‡∂±‡∑ä ‡∑É‡∑ù‡∂©‡∑è ‡∂¥‡∑í‡∂Ω‡∑í‡∂∫‡∑ô‡∂Ω ‡∂ö‡∑í‡∂ª‡∑ì‡∂∏.",
      "‡∂¥‡∑ñ‡∂¢‡∑è ‡∂Ø‡∑ä‚Äç‡∂ª‡∑Ä‡∑ä‚Äç‡∂∫ ‡∂ú‡∑ô‡∂± ‡∂Ü ‡∂Ω‡∂∏‡∑î‡∂±‡∑ä ‡∑É‡∂ß‡∑Ñ‡∂±‡∑ä ‡∂ö‡∂ª ‡∂ú‡∑ê‡∂±‡∑ì‡∂∏.",
      "‡∂∂‡∑î‡∂Ø‡∑ä‡∂Ø ‡∑Ä‡∂±‡∑ä‡∂Ø‡∂±‡∑è‡∑Ä‡∂ß ‡∂Ö‡∑Ä‡∑Å‡∑ä‚Äç‡∂∫ ‡∑Å‡∂∂‡∑ä‡∂Ø ‡∑Ä‡∑í‡∂ö‡∑è‡∑Å‡∂± ‡∂∫‡∂±‡∑ä‡∂≠‡∑ä‚Äç‡∂ª ‡∑É‡∂ö‡∑É‡∑ä ‡∂ö‡∂ª ‡∂ú‡∑ê‡∂±‡∑ì‡∂∏.",
      "‡∂∂‡∑î‡∂Ø‡∑ä‡∂Ø ‡∑Ä‡∂±‡∑ä‡∂Ø‡∂±‡∑è‡∑Ä‡∂ß ‡∑Ä‡∑ê‡∂©‡∂∏ ‡∂ö‡∂ª‡∂± ‡∑É‡∑ä‡∑Ä‡∑è‡∂∏‡∑í‡∂±‡∑ä ‡∑Ä‡∑Ñ‡∂±‡∑ä‡∑É‡∑ö‡∂ú‡∑ö ‡∂Ü‡∑É‡∂±‡∂∫‡∂ß ‡∑É‡∑î‡∂Ø‡∑î ‡∂ª‡∑ô‡∂Ø‡∑ä‡∂Ø‡∂ö‡∑ä ‡∂Ø‡∑ê‡∂∏‡∑ì‡∂∏.",
      "‡∂∂‡∑î‡∂Ø‡∑ä‡∂Ø ‡∑Ä‡∂±‡∑ä‡∂Ø‡∂±‡∑è‡∑Ä ‡∂ö‡∂ª‡∂± ‡∑É‡∑ä‡∂Æ‡∑è‡∂±‡∂∫‡∂ß ‡∂¥‡∑ê‡∂Ø‡∑î‡∂ª‡∑î ‡∂Ø‡∑ê‡∂∏‡∑ì‡∂∏‡∑ä.",
      "‡∂¥‡∑ô.‡∑Ä 7.25 ‡∑É‡∑ì‡∂±‡∑î‡∑Ä ‡∂±‡∑è‡∂Ø ‡∂ö‡∑í‡∂ª‡∑ì‡∂∏.",
      "‡∑É‡∑í‡∑É‡∑î‡∂±‡∑ä ‡∂∂‡∑î‡∂Ø‡∑ä‡∂Ø ‡∑Ä‡∂±‡∑ä‡∂Ø‡∂±‡∑è‡∑Ä‡∂ß ‡∂¥‡∑ô‡∂Ω ‡∂ú‡∑É‡∑ä‡∑Ä‡∑è ‡∂ú‡∑ê‡∂±‡∑ì‡∂∏.",
      "‡∑É‡∑ë ‡∂∏‡∂Ω‡∑î‡∑Ä‡∂ß ‡∂á‡∂≠‡∑î‡∂Ω‡∑ä‡∑Ä‡∑ô‡∂± ‡∂Ø‡∑ú‡∂ª‡∂ß‡∑î‡∑Ä‡∑ô‡∂±‡∑ä ‡∑É‡∑í‡∂∫‡∂Ω‡∑î‡∂∏ ‡∑É‡∑í‡∑É‡∑î‡∂±‡∑ä ‡∂¥‡∑ô‡∂Ω‡∂ú‡∑É‡∑ä‡∑Ä‡∑è ‡∂ú‡∑ê‡∂±‡∑ì‡∂∏.",
      "‡∂¥‡∑è‡∑Ä‡∑Ñ‡∂±‡∑ä ‡∂∂‡∑ê‡∂Ω‡∑ì‡∂∏.",
      "‡∑É‡∑ë ‡∂∏‡∂Ω‡∑î‡∑Ä‡∂ß ‡∂á‡∂≠‡∑î‡∂Ω‡∑ä‡∑Ä‡∑ô‡∂± ‡∂Ø‡∑ú‡∂ª‡∂ß‡∑î‡∑Ä‡∑ô‡∂±‡∑ä ‡∑É‡∑í‡∂∫‡∂Ω‡∑î‡∂∏ ‡∑É‡∑í‡∑É‡∑î‡∂±‡∑ä ‡∂Ø‡∂± ‡∂±‡∂∏‡∑É‡∑ä‡∂ö‡∑è‡∂ª ‡∂ö‡∂ª ‡∂á‡∂≠‡∑î‡∂Ω‡∑ä ‡∑Ä‡∑ì‡∂∏.",
      "‡∂∂‡∑î‡∂Ø‡∑ä‡∂Ø ‡∑Ä‡∂±‡∑ä‡∂Ø‡∂±‡∑è‡∑Ä‡∂ß ‡∑É‡∑ä‡∑Ä‡∑è‡∂∏‡∑ì‡∂±‡∑ä ‡∑Ä‡∑Ñ‡∂±‡∑ä‡∑É‡∑ö ‡∑Ä‡∂©‡∂∏‡∑Ä‡∑ì‡∂∏.",
      "‡∑É‡∑í‡∂∫‡∂Ω‡∑î‡∂∏ ‡∑É‡∑í‡∑É‡∑î‡∂±‡∑ä ‡∂≠‡∑ô‡∂ª‡∑î‡∑Ä‡∂±‡∑ä ‡∑É‡∂£‡∑ä‡∂¢‡∑è‡∂∫‡∂±‡∑è ‡∂ö‡∑ú‡∂ß ‡∂ú‡∑í‡∂Ω‡∂±‡∑ä‡∂¥‡∑É,‡∂∏‡∂Ω‡∑ä ‡∂Ü‡∂Ø‡∑í‡∂∫ ‡∂¥‡∑î‡∂¢‡∂±‡∑ì‡∂∫ ‡∑É‡∑ä‡∂Æ‡∑è‡∂± ‡∂â‡∂Ø‡∑í‡∂ª‡∑í‡∂∫‡∑ô ‡∂≠‡∑ê‡∂±‡∑ä‡∂¥‡∂≠‡∑ä ‡∂ö‡∑í‡∂ª‡∑ì‡∂∏.",
      "‡∑É‡∑í‡∂∫‡∂Ω‡∑î‡∂∏ ‡∑É‡∑í‡∑É‡∑î‡∂±‡∑ä ‡∂Ø‡∑ë‡∑É‡∑ä ‡∂¥‡∑í‡∂∫‡∂ú‡∑ô‡∂± ‡∑É‡∂≠‡∑í‡∂∏‡∂≠‡∑ä ‡∂∂‡∑Ä‡∑í‡∂±‡∑ä ‡∂∂‡∑î‡∂Ø‡∑ä‡∂Ø ‡∑Ä‡∂±‡∑ä‡∂Ø‡∂±‡∑è‡∑Ä ‡∂ö‡∑í‡∂ª‡∑ì‡∂∏.",
      "‡∑Å‡∂∂‡∑ä‡∂Ø ‡∑Ä‡∑í‡∂ö‡∑è‡∑Å‡∂± ‡∂∫‡∂±‡∑ä‡∂≠‡∑ä‚Äç‡∂ª ‡∂∏‡∂ú‡∑í‡∂±‡∑ä ‡∂Ø‡∑Ñ‡∂∏‡∑ä ‡∂¥‡∑è‡∑É‡∂Ω‡∑ä ‡∂ú‡∑ì‡∂≠‡∂∫ ‡∂ú‡∑è‡∂∫‡∂±‡∑è ‡∂ö‡∑í‡∂ª‡∑ì‡∂∏ ‡∑Ñ‡∑è ‡∑Å‡∑í‡∑Ç‡∑ä‚Äç‡∂∫ ‡∂¥‡∑ä‚Äç‡∂ª‡∂≠‡∑í‡∂£‡∑è‡∑Ä ‡∂ã‡∑É‡∑ä ‡∑Ñ‡∂Ø‡∑í‡∂±‡∑ä ‡∂ö‡∑ì‡∂∏.",
      "‡∂Ø‡∑Ä‡∑É‡∑ö ‡∑Ä‡∑ê‡∂©‡∑É‡∂ß‡∑Ñ‡∂± ‡∑Ñ‡∑ù ‡∂Ø‡∑Ä‡∑É‡∂ß ‡∂Ö‡∂Ø‡∑è‡∑Ö ‡∂ã‡∂¥‡∂Ø‡∑ö‡∑Å‡∂ö ‡∂ú‡∑ì‡∂≠‡∂∫ ‡∑É‡∑ë‡∂∏ ‡∂Ø‡∑ô‡∂±‡∑è‡∂∏ ‡∂ë‡∂ö‡∂ß ‡∂ú‡∑è‡∂∫‡∂±‡∑è ‡∂ö‡∑í‡∂ª‡∑ì‡∂∏.",
      "‡∑É‡∑í‡∂∫‡∂Ω‡∑î‡∂∏ ‡∑É‡∑í‡∑É‡∑î‡∂±‡∑ä ‡∑Ä‡∑è‡∂©‡∑í ‡∑Ä‡∑ì ‡∑É‡∑í‡∂ß‡∑í‡∂± ‡∂¥‡∑ê‡∂Ø‡∑î‡∂ª‡∑î ‡∂î‡∑Ä‡∑î‡∂±‡∑ä ‡∂Ω‡∑Ä‡∑è ‡∂Ö‡∂ö‡∑î‡∂Ω‡∑è ‡∂Ø‡∂ª‡∑ä‡∂∏‡∑Å‡∑è‡∂Ω‡∑è‡∑Ä‡∑ö ‡∂≠‡∑ê‡∂±‡∑ä‡∂¥‡∂≠‡∑ä ‡∂ö‡∑í‡∂ª‡∑ì‡∂∏.",
      "‡∂∂‡∑î‡∂Ø‡∑ä‡∂Ø ‡∑Ä‡∂±‡∑ä‡∂Ø‡∂±‡∑è‡∑Ä ‡∂ú‡∂≠‡∑ä ‡∂ú‡∑í‡∂Ω‡∂±‡∑ä‡∂¥‡∑É ‡∂∂‡∑è‡∂¢‡∂± ‡∑É‡∑ù‡∂Ø‡∑è ‡∂¥‡∑Ñ‡∂± ‡∂±‡∑í‡∑É‡∑í ‡∂≠‡∑ê‡∂± ‡∂≠‡∑ê‡∂∂‡∑ì‡∂∏.",
      "‡∂Ø‡∑í‡∂±‡∂ß ‡∂¥‡∑ê‡∂∏‡∑í‡∂´‡∑ì ‡∑É‡∑í‡∑É‡∑î‡∂±‡∑ä ‡∂ú‡∂±‡∂±‡∂∫ ‡∂ö‡∑í‡∂ª‡∑ì‡∂∏ . ‡∂±‡∑í‡∂∫‡∂¥‡∑ú‡∂≠‡∑î,‡∂∂‡∑ê‡∂¢‡∑ä ‡∂¥‡∑ê‡∂Ω‡∂Ø‡∑ì‡∂∏,‡∑Ñ‡∑í‡∑É ‡∂±‡∑í‡∑Ä‡∑ê‡∂ª‡∑ê‡∂Ø‡∑í ‡∑Ä ‡∂¥‡∑ì‡∂ª‡∑è ‡∂¥‡∂ª‡∑ì‡∂ö‡∑ä‡∑Å‡∑è ‡∂ö‡∑í‡∂ª‡∑ì‡∂∏.",
      "‡∂¥‡∑ô.‡∑Ä 8.30 ‡∑É‡∑ì‡∂±‡∑î‡∑Ä ‡∂±‡∑è‡∂Ø ‡∂ö‡∑í‡∂ª‡∑ì‡∂∏.",
      "‡∂∂‡∂±‡∑í‡∑É‡∑ä ‡∂¥‡∑ú‡∂≠‡∑ä ‡∂Ü‡∂Ø‡∑í‡∂∫ ‡∂Ω‡∂ö‡∑î‡∂´‡∑î ‡∂ö‡∑í‡∂ª‡∑ì‡∂∏.",
      "‡∂¥‡∑ô.‡∑Ä 10.00 ‡∑É‡∑ì‡∂±‡∑î‡∑Ä ‡∂±‡∑è‡∂Ø ‡∂ö‡∑í‡∂ª‡∑ì‡∂∏.",
      "‡∑É‡∑í‡∂∫‡∂Ω‡∑î‡∂∏ ‡∑É‡∑í‡∑É‡∑î‡∂±‡∑ä ‡∂≠‡∑ö ‡∂¥‡∑è‡∂±‡∂∫ ‡∑É‡∂Ø‡∑Ñ‡∑è 1‡∑É‡∑í‡∂ß ‡∂¥‡∑í‡∂Ω‡∑í‡∑Ä‡∑ô‡∑Ö‡∂ß ‡∂ú‡∑ô‡∂± ‡∂∫‡∑è‡∂∏.",
      "‡∂¥‡∑ä‚Äç‡∂ª‡∂Ø‡∑è‡∂± ‡∂ú‡∑ö‡∂ß‡∑ä‡∂ß‡∑î‡∑Ä ‡∑Ä‡∑ê‡∑É‡∑ì‡∂∏.",
      "‡∂¥‡∑ô.‡∑Ä 10.30 ‡∑É‡∑ì‡∂±‡∑î‡∑Ä ‡∂±‡∑è‡∂Ø‡∂∫ ‡∂ö‡∑í‡∂ª‡∑ì‡∂∏,‡∑É‡∑í‡∂∫‡∂Ω‡∑î‡∂∏ ‡∑É‡∑í‡∑É‡∑î‡∂±‡∑ä ‡∂â‡∂≠‡∑è ‡∂â‡∂ö‡∑ä‡∂∏‡∂±‡∑í‡∂±‡∑ä ‡∂¥‡∂±‡∑ä‡∂≠‡∑í ‡∑Ä‡∂Ω‡∂ß ‡∂ú‡∑ô‡∂±‡∑ä‡∑Ä‡∑è ‡∂ú‡∑ê‡∂±‡∑ì‡∂∏.",
      "‡∂ú‡∑î‡∂ª‡∑î‡∑Ä‡∂ª‡∑î‡∂±‡∑ä ‡∂Ö‡∂Ø‡∑è‡∑Ö ‡∂¥‡∂±‡∑ä‡∂≠‡∑í ‡∑Ä‡∂Ω‡∂ß ‡∂∫‡∑ú‡∂∏‡∑î ‡∂ö‡∂ª‡∑Ä‡∑ì‡∂∏.",
      "‡∑Ä‡∑í‡∑Ä‡∑ö‡∂ö ‡∂ö‡∑è‡∂Ω‡∂∫ ‡∂Ö‡∂≠‡∂ª‡∂≠‡∑î‡∂ª ‡∂ä‡∂Ω‡∂ú ‡∑É‡∂≠‡∑í‡∂∫‡∂ß ‡∂Ö‡∂Ø‡∑è‡∂Ω ‡∑Ä‡∑ê‡∂©‡∑É‡∂ß‡∑Ñ‡∂± ‡∑É‡∑ñ‡∂Ø‡∑è‡∂±‡∂∏‡∑ä ‡∂ö‡∑í‡∂ª‡∑ì‡∂∏.",
      "‡∂¥‡∑ô.‡∑Ä 11.45 ‡∑É‡∑ì‡∂±‡∑î‡∑Ä ‡∂±‡∑è‡∂Ø ‡∂ö‡∑í‡∂ª‡∑ì‡∂∏.",
      "‡∑Ñ‡∑ê‡∂ö‡∑í ‡∂â‡∂ö‡∑ä‡∂∏‡∂±‡∑í‡∂±‡∑ä ‡∂©‡∑ô‡∑É‡∑ä ‡∂∂‡∂Ç‡∂ö‡∑î ‡∂±‡∑í‡∑É‡∑í ‡∂≠‡∑ê‡∂± ‡∂≠‡∑ê‡∂∂‡∑ì‡∂∏‡∂ß ‡∑É‡∑í‡∑É‡∑î‡∂±‡∑ä ‡∂∏‡∑ô‡∑Ñ‡∑ô‡∂∫‡∑Ä‡∑ì‡∂∏.",
      "‡∑É‡∑í‡∂∫‡∂Ω‡∑î‡∂∏ ‡∑É‡∑í‡∑É‡∑î‡∂±‡∑ä ‡∂ú‡∑è‡∂Æ‡∑è ‡∑É‡∂£‡∑ä‡∂¢‡∑è‡∂∫‡∂±‡∂∫‡∂ß ‡∂¥‡∑ô‡∑Ö ‡∂ú‡∑É‡∑ä‡∑Ä‡∑è ‡∂ú‡∑ê‡∂±‡∑ì‡∂∏. ‡∂±‡∑í‡∂ª‡∂≠‡∑î‡∂ª‡∑î‡∑Ä‡∂∏ ‡∂±‡∑í‡∑Ñ‡∂© ‡∂∂‡∑Ä ‡∂≠‡∑í‡∂∫‡∑è ‡∂ú‡∑ê‡∂±‡∑ì‡∂∏.",
      "‡∑Å‡∂∂‡∑ä‡∂Ø ‡∑Ä‡∑í‡∂ö‡∑è‡∑Å‡∂± ‡∂∫‡∂±‡∑ä‡∂≠‡∑ä‚Äç‡∂ª‡∂∫ ‡∂∏‡∂ú‡∑í‡∂±‡∑ä ‡∂ú‡∑è‡∂Æ‡∑è ‡∑É‡∂£‡∑ä‡∂¢‡∑è‡∂∫‡∂±‡∑è‡∑Ä.",
      "‡∂Ø‡∂ª‡∑ä‡∂∏‡∑Å‡∑è‡∂Ω‡∑è‡∑Ä ‡∂¥‡∑í‡∂ª‡∑í‡∑É‡∑í‡∂Ø‡∑î ‡∂ö‡∑í‡∂ª‡∑ì‡∂∏.",
      "‡∂¥‡∑ñ‡∂¢‡∑è ‡∂∑‡∑è‡∂´‡∑ä‡∂© ‡∂ö‡∂∂‡∂©‡∑ä ‡∂ë‡∂ö ‡∂ú‡∂≠‡∑ä ‡∂ú‡∑í‡∂Ω‡∂±‡∑ä‡∂¥‡∑É ‡∂ß‡∑ä‚Äç‡∂ª‡∑ö ‡∂Ü‡∂Ø‡∑í ‡∂∑‡∑è‡∂´‡∑ä‡∂© ‡∂±‡∑ê‡∑Ä‡∂≠ ‡∂≠‡∑ê‡∂∂‡∑ì‡∂∏ ‡∂ö‡∑ô‡∂ª‡∑ô‡∑Ñ‡∑í ‡∂∂‡∑ê‡∂Ω‡∑ì‡∂∏.",
      "‡∑Å‡∑í‡∑Ç‡∑ä‚Äç‡∂∫‡∂∫‡∑í‡∂±‡∑ä‡∂ß ‡∂Ö‡∂∏‡∂≠‡∂ö‡∑Ä‡∑ì ‡∂á‡∂≠‡∑í ‡∑Ä‡∂≠‡∑î‡∂ª ‡∂∂‡∑ù‡∂≠‡∂Ω‡∑ä ‡∑Ñ‡∑è ‡∂¥‡∑ú‡∂≠‡∑ä‡∂¥‡∂≠‡∑ä ‡∂Ü‡∂Ø‡∑í‡∂∫ ‡∂∂‡∑ê‡∂Ω‡∑ì‡∂∏.",
      "‡∑É‡∑í‡∂∫‡∂Ω‡∑î‡∂∏ ‡∑Å‡∑í‡∑Ç‡∑ä‚Äç‡∂∫ ‡∂±‡∑è‡∂∫‡∂ö ‡∂±‡∑è‡∂∫‡∑í‡∂ö‡∑è‡∑Ä‡∂±‡∑ä ‡∂Ø‡∑í‡∂±‡∂∫‡∂ß ‡∂Ö‡∂Ø‡∑è‡∂Ω‡∑Ä ‡∑É‡∑í‡∂Ø‡∑î ‡∂ö‡∂Ω ‡∑Ä‡∑ê‡∂© ‡∂ö‡∂ß‡∂∫‡∑î‡∂≠‡∑î ‡∑É‡∑ä‡∂∏‡∂ª‡∂´‡∂∫ ‡∂ö‡∑í‡∂ª‡∑ì‡∂∏ ‡∑É‡∑í‡∂Ø‡∑î‡∑Ä‡∑î‡∂±‡∑î ‡∂Ö‡∂©‡∑î‡∂¥‡∑è‡∂©‡∑î‡∂ö‡∂∏‡∑ä ‡∑Ä‡∑ô‡∂≠‡∑ä‡∂±‡∂∏‡∑ä ‡∂ë‡∂∫ ‡∑Ñ‡∂Ø‡∑î‡∂±‡∑è ‡∂ú‡∑ê‡∂±‡∑ì‡∂∏. ‡∂±‡∑ê‡∑Ä‡∂≠ ‡∑É‡∑í‡∂Ø‡∑î ‡∂±‡∑ú‡∑Ä‡∑ì‡∂∏‡∂ß ‡∑Ä‡∂ú ‡∂∂‡∂Ω‡∑è ‡∂ú‡∑ê‡∂±‡∑ì‡∂∏.",
      "‡∂Ø‡∑í‡∂±‡∂∫‡∑ö ‡∑É‡∑í‡∂Ø‡∑î‡∂ö‡∂ª ‡∂ö‡∑è‡∂ª‡∑ä‚Äç‡∂∫ ‡∂∂‡∑è‡∂ª‡∂∫ ‡∑Ñ‡∑è ‡∂Ö‡∂©‡∑î‡∂¥‡∑è‡∂©‡∑î ‡∂¥‡∑í‡∂Ω‡∑í‡∂∂‡∂Ø‡∑Ä ‡∂ä‡∂Ω‡∂ú ‡∑É‡∂≠‡∑í‡∂∫‡∑ö ‡∂ö‡∂Ω ‡∂∫‡∑î‡∂≠‡∑î ‡∑Ä‡∑ê‡∂©‡∑É‡∂ß‡∑Ñ‡∂±‡∑ä ‡∂¥‡∑í‡∂Ω‡∑í‡∂∂‡∂Ø‡∑Ä ‡∑Ä‡∂ú‡∂ö‡∑í‡∂∫ ‡∂∫‡∑î‡∂≠‡∑î ‡∂ú‡∑î‡∂ª‡∑î‡∑Ä‡∂ª‡∑î‡∂±‡∑ä ‡∂Ø‡∑ô‡∂Ø‡∑ô‡∂±‡∂ö‡∑î ‡∂â‡∂Ø‡∑í‡∂ª‡∑í‡∂∫‡∑ö ‡∂Ø‡∑ê‡∂±‡∑î‡∑Ä‡∂≠‡∑ä ‡∂ö‡∑í‡∂ª‡∑ì‡∂∏.",
      "‡∑É‡∂≠‡∑í‡∂∏‡∂≠‡∑ä ‡∂∂‡∑Ä‡∑í‡∂±‡∑ä ‡∂∫‡∑î‡∂≠‡∑î‡∑Ä ‡∂ú‡∑î‡∂ª‡∑î‡∑Ä‡∂ª‡∑î‡∂±‡∑ä ‡∂±‡∑ê‡∂∏‡∂Ø ‡∂Ø‡∑Ñ‡∂∏‡∑ä ‡∂¥‡∑è‡∑É‡∂Ω‡∑í‡∂±‡∑ä ‡∂¥‡∑í‡∂ß‡∂≠‡∑ä ‡∑Ä‡∑ì‡∂∏."
    ];

    // Names (as you provided)
    const specialNames = ["‡∑Ü‡∂ª‡∑ä‡∑Ñ‡∑è‡∂±‡∑ä ‡∑Ñ‡∂ö‡∑ä", "‡∑Ä‡∂ª‡∂± ‡∑Ä‡∑í‡∂ª‡∑ú‡∂†‡∂±", "‡∑É‡∑ô‡∂±‡∑î‡∂≠‡∑ä ‡∂Ø‡∑í‡∂±‡∑ä‡∑É‡∂ª", "‡∂∏‡∂±‡∑î‡∂≠‡∑ä ‡∂©‡∑í‡∑Ñ‡∑ô‡∂±‡∑ä", "‡∂Ø‡∑í‡∂±‡∑ô‡∂≠‡∑ä ‡∂Ø‡∂∏‡∑ä‡∑É‡∂ª"];
    const otherNames = [
      "‡∂∫‡∑ú‡∂∏‡∑è‡∂Ω‡∑í ‡∂±‡∑ô‡∂≠‡∑ä‡∂∏‡∑í‡∂±‡∑í", "‡∂∏‡∑í‡∂≠‡∑î‡∂±‡∑í ‡∂ö‡∑Ä‡∑í‡∑Å‡∑è", "‡∑É‡∑í‡∂Ø‡∂Ç‡∂ú‡∂±‡∑è ‡∂Ø‡∂∏‡∑ä‡∑É‡∑í‡∂Ω‡∑î‡∂±‡∑í", "‡∂Ø‡∑ê‡∑Ñ‡∑ê‡∂∏‡∑í ‡∂±‡∑ô‡∂≠‡∑ä‡∑É‡∂ª‡∑è",
      "‡∂î‡∑Å‡∑í‡∂±‡∑í ‡∂ã‡∂∏‡∑ô‡∑Å‡∑í‡∂ö‡∑è", "‡∂ö‡∑í‡∑Ä‡∑í‡∂Ø‡∑í ‡∂¢‡∂∫‡∑ù‡∂Ø‡∑ä‚Äç‡∂∫‡∑è", "‡∂Ö‡∂¥‡∑î‡∂ª‡∑ä‡∑Ä‡∑í ‡∂∏‡∂≠‡∑í‡∑Å‡∑è", "‡∂∫‡∑ô‡∑Ñ‡∑ô‡∂±‡∑í ‡∂∂‡∑Ä‡∂±‡∑ä‡∂∫‡∑è",
      "‡∂ª‡∂±‡∑î‡∂≠‡∑ä‡∂∏‡∑í ‡∑É‡∑î‡∑Ñ‡∂±‡∑ä‚Äç‡∂∫‡∑è", "‡∂≠‡∑Å‡∂∏‡∑ä‡∂∏‡∑í ‡∂†‡∑ô‡∂±‡∑è‡∂Ω‡∑è"
    ];
    const allNames = specialNames.concat(otherNames);

    // Your groups (kept the original indices as provided)
    const setA = [11, 14, 27, 29, 32, 35]; // indices used to assign specialNames fairly
    const setB = [3, 4, 5, 6, 7, 8, 9, 13, 25, 26, 28, 30, 37, 39, 40]; // indices where two names are assigned
    const setC = [1, 2, 15, 16, 18, 20, 21, 22, 23, 24, 32, 33, 34, 36, 38, 41, 42, 43, 44]; // fixed-name indices

    // fixed text for Set C
    const fixedName = "‡∑É‡∑í‡∂∫‡∂Ω‡∑î ‡∑Å‡∑í‡∑Ç‡∑ä‚Äç‡∂∫ ‡∂±‡∑è‡∂∫‡∂ö ‡∂±‡∑è‡∂∫‡∑í‡∂ö‡∑è‡∑Ä‡∂±‡∑ä";

    // Helper: Fisher-Yates shuffle
    function shuffleArray(a) {
      const arr = a.slice();
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    // Helper: create a cycling generator for an array (fair rotation)
    function createCycle(arr) {
      let pool = shuffleArray(arr);
      return function next() {
        if (pool.length === 0) pool = shuffleArray(arr);
        return pool.shift();
      };
    }

    // Utility to pick least-used name respecting an exclude set and "locked" names
    function pickLeastUsedName(usageMap, exclude = new Set()) {
      // Build list of candidates
      const candidates = allNames.filter(n => !exclude.has(n));
      // Sort by usage count (ascending)
      candidates.sort((a, b) => (usageMap[a] || 0) - (usageMap[b] || 0));
      // Return first candidate (lowest usage)
      return candidates.length ? candidates[0] : null;
    }

    function shuffleAndRender() {
      const tbody = document.getElementById("taskTableBody");
      tbody.innerHTML = "";

      // Prepare assignments array
      const assignments = new Array(sentences.length).fill("");

      // Usage tracker for fairness
      const usage = {};
      function incUsage(name) { usage[name] = (usage[name] || 0) + 1; }

      // 1) Sentence 1 fixed to "‡∑Ü‡∂ª‡∑ä‡∑Ñ‡∑è‡∂±‡∑ä ‡∑Ñ‡∂ö‡∑ä" (index 0)
      assignments[0] = "‡∑Ü‡∂ª‡∑ä‡∑Ñ‡∑è‡∂±‡∑ä ‡∑Ñ‡∂ö‡∑ä";
      incUsage("‡∑Ü‡∂ª‡∑ä‡∑Ñ‡∑è‡∂±‡∑ä ‡∑Ñ‡∂ö‡∑ä");

      // 2) Set C -> fixedName
      setC.forEach(idx => {
        if (idx >= 0 && idx < assignments.length) {
          assignments[idx] = fixedName;
        }
      });

      // 3) Special rotation for Set A (ensure fair use of specialNames)
      // We'll allow specialNames to be used in setA in a cycle (includes ‡∑Ü‡∂ª‡∑ä‡∑Ñ‡∑è‡∂±‡∑ä ‡∑Ñ‡∂ö‡∑ä)
      const nextSpecial = createCycle(specialNames);
      // But we must ensure we don't accidentally override fixed entries (e.g., if an index is in setC)
      setA.forEach(idx => {
        if (idx >= 0 && idx < assignments.length && !assignments[idx]) {
          const name = nextSpecial();
          assignments[idx] = name;
          incUsage(name);
        }
      });

      // 4) Special restriction: if the bag-check sentence (index 4) is in setB ‚Äî we must assign it two names
      //    and lock them until the 7:25 sentence (index 14) occurs.
      // Find if index 4 is in setB; if not present, treat index 4 specially anyway because user wanted it.
      const bagIdx = 4; // "‡∑Å‡∑í‡∑Ç‡∑ä‚Äç‡∂∫‡∂∫‡∂±‡∑ä‡∂ú‡∑ö ‡∂∂‡∑ë‡∂ú‡∑ä ‡∂¥‡∂ª‡∑ì‡∂ö‡∑ä‡∑Ç‡∑è‡∑Ä." is index 4 (0-based)
      const sevenTwentyFiveIdx = 14; // "‡∂¥‡∑ô.‡∑Ä 7.25 ‡∑É‡∑ì‡∂±‡∑î‡∑Ä ‡∂±‡∑è‡∂Ø ‡∂ö‡∑í‡∂ª‡∑ì‡∂∏." is index 14 (0-based)

      // We'll prepare pair pools for setB: list of possible pairs, and used pairs.
      function pairKey(a, b) {
        // normalized key for pair (order-insensitive)
        return [a, b].sort().join(" | ");
      }

      // Build a pool of possible pairs (all combinations of two different names)
      const allPairs = [];
      for (let i = 0; i < allNames.length; i++) {
        for (let j = i + 1; j < allNames.length; j++) {
          allPairs.push([allNames[i], allNames[j]]);
        }
      }

      // Shuffle pairs for variety, but we'll pick by usage preference later
      let availablePairs = shuffleArray(allPairs.slice());
      const usedPairKeys = new Set();

      // Locked names from bag-check (to be excluded from other assignments until sevenTwentyFiveIdx is reached)
      let lockedNames = new Set();

      // Helper: choose a pair for an index with constraints (exclude locked usage if index < sevenTwentyFiveIdx)
      function choosePairForIndex(idx, excludeNames = new Set()) {
        // Prefer pairs where both names are not in excludeNames and minimize usages
        // Build candidate pairs filtered
        const candidates = availablePairs.filter(pair => {
          const [a, b] = pair;
          if (excludeNames.has(a) || excludeNames.has(b)) return false;
          return true;
        });

        if (candidates.length === 0) {
          // if no candidates remain (rare), regenerate from allPairs excluding used pairs and excluded names
          availablePairs = shuffleArray(allPairs.filter(pair => {
            const k = pairKey(pair[0], pair[1]);
            if (usedPairKeys.has(k)) return false;
            if (excludeNames.has(pair[0]) || excludeNames.has(pair[1])) return false;
            return true;
          }));
        }

        // After filtering, pick pair that minimizes combined usage
        let best = null;
        let bestScore = Infinity;
        const pool = candidates.length ? candidates : availablePairs;
        for (const pair of pool) {
          const [a, b] = pair;
          const score = (usage[a] || 0) + (usage[b] || 0);
          // also prefer pairs not yet used
          const usedPenalty = usedPairKeys.has(pairKey(a, b)) ? 1000 : 0;
          const total = score + usedPenalty + Math.random() * 0.1; // small random tiebreak
          if (total < bestScore) {
            bestScore = total;
            best = pair;
          }
        }

        if (!best) {
          // fallback: random pair ignoring excludeNames (shouldn't happen normally)
          best = allPairs[Math.floor(Math.random() * allPairs.length)];
        }

        // Mark pair as used
        const k = pairKey(best[0], best[1]);
        usedPairKeys.add(k);
        // also remove from availablePairs so we avoid immediate reuse
        availablePairs = availablePairs.filter(p => pairKey(p[0], p[1]) !== k);

        // increment usage counters
        incUsage(best[0]);
        incUsage(best[1]);

        return best;
      }

      // 5) Assign pairs for setB in index order, but ensure that the bagIdx pair gets locked
      //    and locked names aren't used elsewhere before sevenTwentyFiveIdx.
      // We'll iterate through setB sorted ascending index so locking works correctly.
      const setBsorted = setB.slice().filter(i => i >= 0 && i < sentences.length).sort((a, b) => a - b);

      for (const idx of setBsorted) {
        if (assignments[idx]) continue; // skip if already assigned (e.g., setC or setA)
        // Determine exclude set for this pick:
        const exclude = new Set();
        // If idx < sevenTwentyFiveIdx, we must exclude lockedNames (they are reserved)
        if (idx < sevenTwentyFiveIdx) {
          lockedNames.forEach(n => exclude.add(n));
        }
        // Also exclude any fixedName (shouldn't be in allNames) but kept for safety
        exclude.add(fixedName);

        // If this is the bagIdx (4) ‚Äî choose pair, assign, then lock them
        if (idx === bagIdx) {
          const pair = choosePairForIndex(idx, exclude);
          assignments[idx] = `${pair[0]}, ${pair[1]}`;
          // lock these names until sevenTwentyFiveIdx has passed
          lockedNames.add(pair[0]);
          lockedNames.add(pair[1]);
          // continue (we already incUsage in choosePairForIndex)
          continue;
        }

        // For other indices: pick pair avoiding locked names when before sevenTwentyFiveIdx
        const pair = choosePairForIndex(idx, exclude);
        assignments[idx] = `${pair[0]}, ${pair[1]}`;
      }

      // 6) Now assign remaining sentences (not setA, not setB, not setC, not sentence 0)
      // We'll do this in index order and respect lockedNames until sevenTwentyFiveIdx.
      for (let idx = 0; idx < sentences.length; idx++) {
        if (assignments[idx]) {
          // Special handling: once we pass the sevenTwentyFiveIdx, we release locked names
          if (idx === sevenTwentyFiveIdx) {
            lockedNames = new Set(); // unlock them now (names can be used again)
          }
          continue;
        }
        // Pick one name for this slot, avoiding locked names if idx < sevenTwentyFiveIdx
        const exclude = new Set();
        if (idx < sevenTwentyFiveIdx) lockedNames.forEach(n => exclude.add(n));
        exclude.add(fixedName);

        const name = pickLeastUsedName(usage, exclude);
        if (name) {
          assignments[idx] = name;
          incUsage(name);
        } else {
          // fallback: choose any name at random (shouldn't occur)
          const randomName = allNames[Math.floor(Math.random() * allNames.length)];
          assignments[idx] = randomName;
          incUsage(randomName);
        }

        // Release locked names if we're exactly at sevenTwentyFiveIdx (they can be reused afterwards)
        if (idx === sevenTwentyFiveIdx) {
          lockedNames = new Set();
        }
      }

      // Final guard: ensure every sentence has an assignment (if any left unfilled)
      for (let i = 0; i < sentences.length; i++) {
        if (!assignments[i]) {
          const name = allNames[Math.floor(Math.random() * allNames.length)];
          assignments[i] = name;
        }
      }

      // Render table rows
      sentences.forEach((task, idx) => {
        const tr = document.createElement("tr");
        tr.innerHTML = `<td>${idx + 1}</td><td>${task}</td><td>${assignments[idx]}</td>`;
        tbody.appendChild(tr);
      });
    }

    // Run once on load
    shuffleAndRender();
  </script>

</body>
</html>
